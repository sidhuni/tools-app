nameOverride: ""
fullnameOverride: ""
# Chart debug mode
# (eg. disable helm hook delete policy)
debug: false
imagePullSecrets: []
# Custom Service account management
serviceAccount:
  # Whether to create service account or not
  create: false
  # Name of the service account.
  # Uses `name` if set.
  # If `create: true` defaults to temporal.fullname, otherwise uses the namespace's default serviceAccount.
  name:
  # extraAnnotations would let users add additional annotations
  extraAnnotations:
additionalAnnotations: {}
additionalLabels: {}
server:
  enabled: true
  image:
    repository: temporalio/server
    tag: 1.29.2
    pullPolicy: IfNotPresent
  # Global default settings (can be overridden per service)
  replicaCount: 1
  readinessProbe: {}
  metrics:
    # Annotate pods and services directly with the following Prometheus annotations.
    # prometheus.io/job
    # prometheus.io/port
    # prometheus.io/scheme
    # prometheus.io/scrape
    annotations:
      enabled: true
    # Additional tags to be added to Prometheus metrics
    tags: {}
    # Tags to be excluded in Prometheus metrics
    excludeTags: {}
    prefix:
    # Enable Prometheus ServiceMonitor
    # Use this if you installed the Prometheus Operator (https://github.com/coreos/prometheus-operator).
    serviceMonitor:
      enabled: false
      interval: 30s
      # Set additional lables to all the ServiceMonitor resources
      additionalLabels: {}
      #  label1: value1
      #  label2: value2
      # Set Prometheus metric_relabel_configs via ServiceMonitor
      # Use metricRelabelings to adjust metric and label names as needed
      metricRelabelings: []
      # - action: replace
      #   sourceLabels:
      #   - exported_namespace
      #   targetLabel: temporal_namespace
      # - action: replace
      #   regex: service_errors_(.+)
      #   replacement: ${1}
      #   sourceLabels:
      #   - __name__
      #   targetLabel: temporal_error_kind
      # - action: replace
      #   regex: service_errors_.+
      #   replacement: temporal_service_errors
      #   sourceLabels:
      #   - __name__
      #   targetLabel: __name__
    prometheus:
      timerType: histogram
  deploymentLabels: {}
  deploymentAnnotations: {}
  deploymentStrategy: {}
  podAnnotations: {}
  podLabels: {}
  secretLabels: {}
  secretAnnotations: {}
  resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #  cpu: 100m
  #  memory: 128Mi
  # requests:
  #  cpu: 100m
  #  memory: 128Mi
  nodeSelector: {}
  tolerations: []
  affinity: {}
  minReadySeconds: 0
  additionalVolumes: []
  additionalVolumeMounts: []
  additionalEnv: []
  # for sidecar containers, add containers here with restartPolicy: Always
  additionalInitContainers: []
  securityContext:
    fsGroup: 1000
    runAsUser: 1000
  config:
    logLevel: "debug,info"
    # Define your TLS configuration here. See https://docs.temporal.io/references/configuration#tls
    # for configuration options. You must also use `server.additionalVolumeMounts` and `server.additionalVolumes`
    # to mount certificates (from Secret or ConfigMap etc) to the path you use below.
    # tls:
    #   internode:
    #     server:
    #       certFile: /path/to/internode/cert/file
    #       keyFile: /path/to/internode/key/file
    #       requireClientAuth: true
    #       clientCaFiles:
    #         - /path/to/internode/serverCa
    #     client:
    #       serverName: dnsSanInInternodeCertificate
    #       rootCaFiles:
    #         - /path/to/internode/serverCa
    #   frontend:
    #     server:
    #       certFile: /path/to/frontend/cert/file
    #       keyFile: /path/to/frontend/key/file
    #       requireClientAuth: true
    #       clientCaFiles:
    #         - /path/to/internode/serverCa
    #         - /path/to/sdkClientPool1/ca
    #         - /path/to/sdkClientPool2/ca
    #     client:
    #       serverName: dnsSanInFrontendCertificate
    #       rootCaFiles:
    #         - /path/to/frontend/serverCa
    # Define your Authorizer and ClaimMapper configuration here. See https://docs.temporal.io/self-hosted-guide/security#authorization
    # authorization:
    #   jwtKeyProvider:
    #     keySourceURIs:
    #       - http://localhost:/jwks.json
    #     refreshInterval: 1m
    #   permissionsClaimName: permissions
    #   authorizer: default
    #   claimMapper: default
    
    persistence:
      defaultStore: default
      visibilityStore: visibility
      numHistoryShards: 512
      datastores:
        default:
          sql:
            pluginName: "postgres12"
            driverName: "postgres12"
            host: "postgresql"  # Matches your fullnameOverride
            port: 5432
            database: "temporal" # Ensure this DB is created or matches your PG config
            user: "admin"        # Matches your postgresql.auth.username
            existingSecret: "postgresql-secrets"
            secretKey: "user_password" # Matches your postgresql.auth.secretKeys
        visibility:
          sql:
            pluginName: "postgres12"
            driverName: "postgres12"
            host: "postgresql"
            port: 5432
            database: "temporal_visibility"
            user: "admin"
            existingSecret: "postgresql-secrets"
            secretKey: "user_password"

 
   
    namespaces:
      # Enable this to create namespaces
      create: false
      namespace:
        - name: default
          retention: 3d
  frontend:
    service:
      # Evaluated as template
      annotations: {}
      type: ClusterIP
      port: 7233
      appProtocol: tcp
      membershipPort: 6933
      membershipAppProtocol: tcp
      httpPort: 7243
      httpAppProtocol: http
    readinessProbe:
      grpc:
        port: 7233
        service: temporal.api.workflowservice.v1.WorkflowService
    ingress:
      enabled: false
      # className:
      annotations: {}
      # kubernetes.io/ingress.class: traefik
      # ingress.kubernetes.io/ssl-redirect: "false"
      # traefik.frontend.rule.type: PathPrefix
      hosts:
        - "/"
        # - "domain.com/xyz"
        # - "domain.com"
      tls: []
      #  - secretName: chart-example-tls
      #    hosts:
      #      - chart-example.local
    metrics:
      annotations:
        enabled: true
      serviceMonitor: {}
      # enabled: false
      prometheus: {}
      # timerType: histogram
    deploymentLabels: {}
    deploymentAnnotations: {}
    deploymentStrategy: {}
    podAnnotations: {}
    podLabels: {}
    resources: {}
    nodeSelector: {}
    tolerations: []
    affinity: {}
    additionalEnv: []
    containerSecurityContext: {}
    topologySpreadConstraints: []
    podDisruptionBudget: {}
  internalFrontend:
    # Enable this to create internal-frontend
    enabled: false
    service:
      # Evaluated as template
      annotations: {}
      type: ClusterIP
      port: 7236
      appProtocol: tcp
      membershipPort: 6936
      membershipAppProtocol: tcp
      httpPort: 7246
      httpAppProtocol: http
    readinessProbe:
      grpc:
        port: 7236
        service: temporal.api.workflowservice.v1.WorkflowService
    metrics:
      annotations:
        enabled: true
      serviceMonitor: {}
      # enabled: false
      prometheus: {}
      # timerType: histogram
    deploymentLabels: {}
    deploymentAnnotations: {}
    deploymentStrategy: {}
    podAnnotations: {}
    podLabels: {}
    resources: {}
    nodeSelector: {}
    tolerations: []
    affinity: {}
    additionalEnv: []
    containerSecurityContext: {}
    topologySpreadConstraints: []
    podDisruptionBudget: {}
  history:
    service:
      # type: ClusterIP
      port: 7234
      appProtocol: tcp
      membershipPort: 6934
      membershipAppProtocol: tcp
    readinessProbe: {}
    metrics:
      annotations:
        enabled: true
      serviceMonitor: {}
      # enabled: false
      prometheus: {}
      # timerType: histogram
    deploymentLabels: {}
    deploymentAnnotations: {}
    deploymentStrategy: {}
    podAnnotations: {}
    podLabels: {}
    resources: {}
    nodeSelector: {}
    tolerations: []
    affinity: {}
    additionalEnv: []
    additionalEnvSecretName: ""
    containerSecurityContext: {}
    topologySpreadConstraints: []
    podDisruptionBudget: {}
  matching:
    service:
      # type: ClusterIP
      port: 7235
      appProtocol: tcp
      membershipPort: 6935
      membershipAppProtocol: tcp
    readinessProbe: {}
    metrics:
      annotations:
        enabled: false
      serviceMonitor: {}
      # enabled: false
      prometheus: {}
      # timerType: histogram
    deploymentLabels: {}
    deploymentAnnotations: {}
    deploymentStrategy: {}
    podAnnotations: {}
    podLabels: {}
    resources: {}
    nodeSelector: {}
    tolerations: []
    affinity: {}
    additionalEnv: []
    containerSecurityContext: {}
    topologySpreadConstraints: []
    podDisruptionBudget: {}
  worker:
    service:
      # type: ClusterIP
      port: 7239
      appProtocol: tcp
      membershipPort: 6939
      membershipAppProtocol: tcp
    readinessProbe: {}
    metrics:
      annotations:
        enabled: true
      serviceMonitor: {}
      # enabled: false
      prometheus: {}
      # timerType: histogram
    deploymentLabels: {}
    deploymentAnnotations: {}
    deploymentStrategy: {}
    podAnnotations: {}
    podLabels: {}
    resources: {}
    nodeSelector: {}
    tolerations: []
    affinity: {}
    additionalEnv: []
    containerSecurityContext: {}
    topologySpreadConstraints: []
    podDisruptionBudget: {}
admintools:
  enabled: true
  image:
    repository: temporalio/admin-tools
    tag: "1.29.1-tctl-1.18.4-cli-1.5.0"
    pullPolicy: IfNotPresent
  service:
    type: ClusterIP
    port: 22
    annotations: {}
  deploymentLabels: {}
  deploymentAnnotations: {}
  deploymentStrategy: {}
  podLabels: {}
  podAnnotations: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}
  additionalVolumes: []
  additionalVolumeMounts: []
  additionalEnv: []
  additionalEnvSecretName: ""
  # for sidecar containers, add containers here with restartPolicy: Always
  additionalInitContainers: []
  resources: {}
  containerSecurityContext: {}
  securityContext: {}
  minReadySeconds: 0
  podDisruptionBudget: {}
web:
  # additionalInitContainers: []
  enabled: true
  replicaCount: 1
  image:
    repository: temporalio/ui
    tag: 2.42.1
    pullPolicy: IfNotPresent
  service:
    # set type to NodePort if access to web needs access from outside the cluster
    # for more info see https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    type: ClusterIP
    # The below clusterIP setting can be set to "None" to make the temporal-web service headless.
    # Note that this requires the web.service.type to be the default ClusterIP value.
    # clusterIP:
    port: 8080
    appProtocol: http
    annotations: {}
    # loadBalancerIP:
  readinessProbe:
    initialDelaySeconds: 10
    httpGet:
      path: /healthz
      port: http
  ingress:
    enabled: false
    # className:
    annotations: {}
    # kubernetes.io/ingress.class: traefik
    # ingress.kubernetes.io/ssl-redirect: "false"
    # traefik.frontend.rule.type: PathPrefix
    hosts:
      - "/"
      # - "domain.com/xyz"
      # - "domain.com"
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local
  deploymentLabels: {}
  deploymentAnnotations: {}
  deploymentStrategy: {}
  podAnnotations: {}
  podLabels: {}
  resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #  cpu: 100m
  #  memory: 128Mi
  # requests:
  #  cpu: 100m
  #  memory: 128Mi
  nodeSelector: {}
  tolerations: []
  affinity: {}
  additionalVolumes: []
  additionalVolumeMounts: []
  # Adjust Web UI config with environment variables:
  # https://docs.temporal.io/references/web-ui-environment-variables
  additionalEnv: []
  additionalEnvSecretName: ""
  containerSecurityContext: {}
  securityContext: {}
  topologySpreadConstraints: []
  minReadySeconds: 0
  podDisruptionBudget: {}
schema:
  backoffLimit: 100
  jobAnnotations: {}
  podAnnotations: {}
  podLabels: {}
  resources: {}
  containerSecurityContext: {}
  securityContext: {}
test:
  podAnnotations: {}
